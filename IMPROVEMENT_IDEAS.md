# OOPStracker 改善案

## 0. プロジェクトの真の目的：リファクタリング可能性の発見

### 現在の課題
- 重複検知は手段であり、目的はリファクタリング機会の発見
- 単純な類似度では実際にリファクタリング可能かわからない
- 複数プロジェクトをまたぐ分析が必要（Git非依存）

### 改善の方向性
- **リファクタリング可能性スコア**の導入
- **統合パターン**の自動提案
- **プロジェクト横断的な分析**フレームワーク

## 1. AST構造比較の改善

### 現在の問題点（検証済み）
- トークンの出現回数を無視（setを使用）→ すべて類似度1.0になる
- トークンの順序を無視
- 型情報が不十分（例：`FUNC:2`のような単純表現）
- フィールド名を無視
- 自己参照の除外ができていない

### 改善案
- **Bag of Words方式**: トークンの出現回数を保持（Counter使用）
- **N-gram方式**: トークンの順序を考慮（2-gram, 3-gram）
- **型情報の強化**: `FIELD:int:id`のようにフィールド名と型を含める
- **構造の深さ考慮**: ネストレベルをトークンに含める（`CALL@L2:Field`）
- **重み付きトークン**: 重要な構造要素（クラス名、関数名）に高い重みを付ける

## 2. SimHashアルゴリズムの改善

### 現在の問題点
- 単純なAST構造のみを使用
- 特徴量が少ない

### 改善案
- **複数の特徴量を組み合わせ**:
  - AST構造
  - 変数名・関数名のセット
  - インポート文
  - コメント（docstring）
  - コードの複雑度メトリクス
- **重み付きSimHash**: 重要な特徴により高い重みを設定
- **MinHash併用**: 大規模データセットでの高速化

## 3. 重複検出ロジックの改善

### 現在の問題点
- 自己参照を除外できていない
- 閾値が固定的
- コンテキストを考慮しない

### 改善案
- **自己参照の確実な除外**: ファイルパス＋行番号でユニーク判定
- **動的閾値**: コードの種類（テスト、モデル、ビジネスロジック）で調整
- **コンテキスト考慮**: 同じファイル内、同じパッケージ内での重複は許容度を上げる
- **意味的類似度**: 関数名・クラス名の意味的類似度も考慮

## 4. 特定パターンへの対応

### Pydanticモデル
- フィールド定義の詳細な解析
- 継承関係の考慮
- バリデータやConfig設定の違いを検出

### データクラス・NamedTuple
- フィールドの順序を重要視
- デフォルト値の有無を区別

### テストコード
- テストケース名を重視
- アサーション内容を比較
- フィクスチャの使用状況

## 5. パフォーマンス改善

### 現在の問題点
- 大規模プロジェクトでの速度
- メモリ使用量

### 改善案
- **インクリメンタル解析**: 変更されたファイルのみ再解析
- **並列処理**: ファイル解析を並列化
- **キャッシュ強化**: AST解析結果のディスクキャッシュ
- **Bloom Filterの活用**: 存在しない重複の高速除外

## 6. ユーザビリティ改善

### レポート機能（リファクタリング重視）
- **リファクタリング可能性グループ化**: 
  - "Extract Method"で解決可能
  - "Extract Class"で解決可能
  - "Template Method Pattern"適用可能
  - "Strategy Pattern"適用可能
  - 意図的な重複（修正不要）
- **統合コード生成**: 実際のリファクタリング後のコードを提案
- **影響範囲の明示**: どのファイル・関数が影響を受けるか
- **優先度付け**: リファクタリングのROI（投資対効果）でソート

### 設定の柔軟性
- **コンテキスト認識設定**: 
  - テストコード用の閾値
  - ファクトリーパターン用の閾値
  - マイグレーション用の閾値
- **プロジェクト横断設定**: 複数プロジェクトの解析パス指定
- **重複許容設定**: `@intentional_duplicate`デコレータの認識

## 7. 高度な解析機能

### IR（中間表現）ベースの解析
- **言語非依存の表現**: Python/Java/JavaScript等を統一IRに変換
- **プロジェクト内での再利用**: 他の解析ツールの基盤として
- **セマンティック情報の保持**: 型情報、フロー情報を含む豊富なIR

### 意図の理解とリファクタリングパターン
- **パターンマッチング**: 
  - 共通の前処理・後処理パターン
  - 似た構造の条件分岐
  - 繰り返される例外処理
- **リファクタリング提案エンジン**:
  - Extract Method（メソッド抽出）
  - Extract Superclass（スーパークラス抽出）
  - Replace Conditional with Polymorphism（多態性への置換）
- **LLMフィードバック統合**: 
  - 生成されたコードの重複をリアルタイムで警告
  - より良い実装パターンの提案

## 8. 統合・連携

### IDE連携
- **リアルタイム検出**: コーディング中の重複警告
- **Quick Fix**: 重複解消のための自動修正提案

### CI/CD連携
- **Pull Request チェック**: 新規重複の検出
- **品質ゲート**: 重複率の閾値設定

### 他ツールとの連携
- **EvoCraft連携**: IR表現を共有し、意図ベースの解析を強化
- **複数プロジェクト分析**: Git非依存でプロジェクト横断的な重複検出
- **メトリクス共有**: 他の品質管理ツールとの統合

## 9. 機械学習アプローチ

### 学習ベースの改善
- **プロジェクト特有の重複パターン学習**
- **偽陽性の学習による精度向上**
- **Code2Vec等の埋め込み手法の活用**

## 10. 実装の優先順位（リファクタリング重視版）

1. **必須**: 自己参照バグの修正
2. **最高**: リファクタリング可能性の判定機能
3. **高**: AST比較の改善（Bag of Words、型情報）
4. **高**: リファクタリングパターンの提案エンジン
5. **高**: IR（中間表現）の基礎実装
6. **中**: Pydanticモデル等の特殊ケース対応
7. **中**: プロジェクト横断分析機能
8. **中**: LLMフィードバック統合の基礎
9. **低**: 高度なパターンマッチング
10. **低**: 機械学習アプローチ

## 11. 新たな改善提案

### セマンティック・フィンガープリント
- **コード意図の埋め込み**: Doc2Vec/Code2Vecでの意図の数値化
- **変数フロー解析**: データフローグラフでの使用パターン追跡
- **制御フロー重視**: CFG（Control Flow Graph）の類似性考慮

### インテリジェントなグルーピング
```python
class RefactoringGrouper:
    def group_by_refactorability(self, duplicates):
        groups = {
            "extract_method": [],      # メソッド抽出で解決
            "extract_class": [],       # クラス抽出で解決
            "template_pattern": [],    # テンプレートメソッド適用
            "strategy_pattern": [],    # ストラテジーパターン適用
            "intentional": []         # 意図的な重複
        }
```

### 影響範囲の可視化（簡易版）
- **静的解析での影響予測**: 呼び出し関係から影響を推定
- **テストカバレッジ連携**: どのテストが影響を受けるか
- **複雑度の変化予測**: リファクタリング前後の複雑度比較