"""
Split Rule Repository - Manages split rules in SQLite database.
Extracted from SmartGroupSplitter to separate data access concerns.
"""

import sqlite3
import logging
from typing import List
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path


@dataclass
class SplitRule:
    """A split rule generated by LLM."""
    pattern: str
    reasoning: str
    created_at: datetime
    success_count: int = 0
    failure_count: int = 0


class SplitRuleRepository:
    """Repository for managing split rules in SQLite."""
    
    def __init__(self, db_path: str = "split_rules.db"):
        self.db_path = db_path
        self.logger = logging.getLogger(__name__)
        self._init_database()
    
    def _init_database(self):
        """Initialize the database schema."""
        try:
            # Ensure directory exists
            db_dir = Path(self.db_path).parent
            if db_dir != Path('.'):
                db_dir.mkdir(parents=True, exist_ok=True)
            
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    CREATE TABLE IF NOT EXISTS split_rules (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        pattern TEXT NOT NULL,
                        reasoning TEXT NOT NULL,
                        created_at TEXT NOT NULL,
                        success_count INTEGER DEFAULT 0,
                        failure_count INTEGER DEFAULT 0
                    )
                ''')
                conn.commit()
        except sqlite3.Error as e:
            self.logger.error(f"Failed to initialize database: {e}")
            raise RuntimeError(f"Cannot initialize split rules database at {self.db_path}: {e}")
        except Exception as e:
            self.logger.error(f"Unexpected error initializing database: {e}")
            raise
    
    def save_rule(self, rule: SplitRule) -> int:
        """Save a split rule to the database."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute('''
                    INSERT INTO split_rules (pattern, reasoning, created_at, success_count, failure_count)
                    VALUES (?, ?, ?, ?, ?)
                ''', (rule.pattern, rule.reasoning, rule.created_at.isoformat(), 
                      rule.success_count, rule.failure_count))
                conn.commit()
                return cursor.lastrowid
        except sqlite3.Error as e:
            self.logger.error(f"Failed to save rule: {e}")
            raise RuntimeError(f"Cannot save split rule to database: {e}")
        except Exception as e:
            self.logger.error(f"Unexpected error saving rule: {e}")
            raise
    
    def get_all_rules(self) -> List[SplitRule]:
        """Get all split rules from the database."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute('''
                    SELECT pattern, reasoning, created_at, success_count, failure_count
                    FROM split_rules
                    ORDER BY success_count DESC, created_at DESC
                ''')
                rules = []
                for row in cursor.fetchall():
                    try:
                        rules.append(SplitRule(
                            pattern=row[0],
                            reasoning=row[1],
                            created_at=datetime.fromisoformat(row[2]),
                            success_count=row[3],
                            failure_count=row[4]
                        ))
                    except Exception as e:
                        self.logger.warning(f"Skipping invalid rule record: {e}")
                        continue
                return rules
        except sqlite3.Error as e:
            self.logger.error(f"Failed to retrieve rules: {e}")
            raise RuntimeError(f"Cannot retrieve split rules from database: {e}")
        except Exception as e:
            self.logger.error(f"Unexpected error retrieving rules: {e}")
            raise
    
    def update_rule_stats(self, pattern: str, success: bool):
        """Update success/failure statistics for a rule."""
        try:
            field = "success_count" if success else "failure_count"
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(f'''
                    UPDATE split_rules
                    SET {field} = {field} + 1
                    WHERE pattern = ?
                ''', (pattern,))
                conn.commit()
        except sqlite3.Error as e:
            self.logger.error(f"Failed to update rule stats: {e}")
            # 統計更新の失敗は致命的ではないため、エラーをログに記録するが例外は投げない
        except Exception as e:
            self.logger.error(f"Unexpected error updating rule stats: {e}")