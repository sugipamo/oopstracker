"""
Repository for managing split rules used by LLM-based group splitting.
"""

import sqlite3
import json
import logging
from typing import List, Optional, Dict, Any
from datetime import datetime
from dataclasses import dataclass, asdict

from .database.connection_manager import DatabaseConnectionManager
from .database.decorators import with_retry


@dataclass
class SplitRule:
    """Represents a split rule generated by LLM."""
    pattern: str
    reasoning: str
    created_at: datetime
    success_count: int = 0
    failure_count: int = 0
    id: Optional[int] = None


class SplitRuleRepository:
    """Repository for managing split rules in the database."""
    
    def __init__(self, db_path: str = "oopstracker.db"):
        self.logger = logging.getLogger(__name__)
        self.db_manager = DatabaseConnectionManager(db_path)
        self._ensure_table_exists()
    
    def _ensure_table_exists(self):
        """Ensure the split_rules table exists."""
        with self.db_manager.transaction():
            self.db_manager.execute("""
                CREATE TABLE IF NOT EXISTS split_rules (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    pattern TEXT NOT NULL,
                    reasoning TEXT NOT NULL,
                    created_at TEXT NOT NULL,
                    success_count INTEGER DEFAULT 0,
                    failure_count INTEGER DEFAULT 0,
                    metadata TEXT
                )
            """)
    
    @with_retry(max_attempts=3)
    def save_rule(self, rule: SplitRule) -> int:
        """Save a split rule to the database with retry on lock."""
        with self.db_manager.transaction():
            cursor = self.db_manager.execute("""
                INSERT INTO split_rules (pattern, reasoning, created_at, success_count, failure_count)
                VALUES (?, ?, ?, ?, ?)
            """, (
                rule.pattern,
                rule.reasoning,
                rule.created_at.isoformat(),
                rule.success_count,
                rule.failure_count
            ))
            rule_id = cursor.lastrowid
            self.logger.info(f"Saved split rule {rule_id}: {rule.pattern}")
            return rule_id
    
    def get_all_rules(self) -> List[SplitRule]:
        """Get all split rules from the database."""
        conn = self.db_manager.connection
        cursor = conn.execute("""
            SELECT id, pattern, reasoning, created_at, success_count, failure_count
            FROM split_rules
            ORDER BY success_count DESC, created_at DESC
        """)
        
        rules = []
        for row in cursor.fetchall():
            rule = SplitRule(
                id=row[0],
                pattern=row[1],
                reasoning=row[2],
                created_at=datetime.fromisoformat(row[3]),
                success_count=row[4],
                failure_count=row[5]
            )
            rules.append(rule)
        
        self.logger.info(f"Retrieved {len(rules)} split rules from database")
        return rules
    
    @with_retry(max_attempts=3)
    def update_rule_stats(self, pattern: str, success: bool):
        """Update success/failure statistics for a rule."""
        with self.db_manager.transaction():
            if success:
                self.db_manager.execute("""
                    UPDATE split_rules
                    SET success_count = success_count + 1
                    WHERE pattern = ?
                """, (pattern,))
            else:
                self.db_manager.execute("""
                    UPDATE split_rules
                    SET failure_count = failure_count + 1
                    WHERE pattern = ?
                """, (pattern,))
            
            self.logger.debug(f"Updated stats for rule '{pattern}': success={success}")
    
    def get_rule_by_pattern(self, pattern: str) -> Optional[SplitRule]:
        """Get a rule by its pattern."""
        conn = self.db_manager.connection
        cursor = conn.execute("""
            SELECT id, pattern, reasoning, created_at, success_count, failure_count
            FROM split_rules
            WHERE pattern = ?
        """, (pattern,))
        
        row = cursor.fetchone()
        if row:
            return SplitRule(
                id=row[0],
                pattern=row[1],
                reasoning=row[2],
                created_at=datetime.fromisoformat(row[3]),
                success_count=row[4],
                failure_count=row[5]
            )
        return None
    
    def delete_ineffective_rules(self, min_success_rate: float = 0.2):
        """Delete rules with low success rates."""
        conn = self.db_manager.connection
        cursor = conn.execute("""
            DELETE FROM split_rules
            WHERE (success_count + failure_count) > 5
            AND (CAST(success_count AS FLOAT) / (success_count + failure_count)) < ?
        """, (min_success_rate,))
        
        deleted = cursor.rowcount
        conn.commit()
        
        if deleted > 0:
            self.logger.info(f"Deleted {deleted} ineffective split rules")
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get statistics about split rules."""
        conn = self.db_manager.connection
        cursor = conn.execute("""
            SELECT 
                COUNT(*) as total_rules,
                SUM(success_count) as total_successes,
                SUM(failure_count) as total_failures,
                AVG(CAST(success_count AS FLOAT) / NULLIF(success_count + failure_count, 0)) as avg_success_rate
            FROM split_rules
        """)
        
        row = cursor.fetchone()
        return {
            'total_rules': row[0] or 0,
            'total_successes': row[1] or 0,
            'total_failures': row[2] or 0,
            'average_success_rate': row[3] or 0.0
        }