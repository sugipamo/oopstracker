"""
Classification rules management for AI analysis.
"""
import sqlite3
import logging
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import List, Optional


@dataclass
class ClassificationRule:
    """A classification rule generated by LLM."""
    pattern: str
    category: str
    reasoning: str
    created_at: datetime
    success_count: int = 0
    failure_count: int = 0


class ClassificationRuleRepository:
    """Repository for managing classification rules in SQLite."""
    
    def __init__(self, db_path: str = "classification_rules.db"):
        self.db_path = db_path
        self.logger = logging.getLogger(__name__)
        self._init_database()
    
    def _init_database(self):
        """Initialize the database schema."""
        try:
            # Ensure directory exists
            db_dir = Path(self.db_path).parent
            if db_dir != Path('.'):
                db_dir.mkdir(parents=True, exist_ok=True)
            
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    CREATE TABLE IF NOT EXISTS classification_rules (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        pattern TEXT NOT NULL,
                        category TEXT NOT NULL,
                        reasoning TEXT NOT NULL,
                        created_at TEXT NOT NULL,
                        success_count INTEGER DEFAULT 0,
                        failure_count INTEGER DEFAULT 0
                    )
                ''')
                conn.commit()
                
                # Add default rules if table is empty
                cursor = conn.execute("SELECT COUNT(*) FROM classification_rules")
                if cursor.fetchone()[0] == 0:
                    self._add_default_rules(conn)
                    
        except sqlite3.Error as e:
            self.logger.error(f"Failed to initialize classification rules database: {e}")
            raise RuntimeError(f"Cannot initialize database at {self.db_path}: {e}")
    
    def _add_default_rules(self, conn: sqlite3.Connection):
        """Add default classification rules for common patterns."""
        default_rules = [
            # Test functions
            ClassificationRule(
                pattern=r"def\s+test_\w+|def\s+\w+_test",
                category="Testing",
                reasoning="Function name starts with 'test_' or ends with '_test', indicating a test function",
                created_at=datetime.now()
            ),
            # Main entry points
            ClassificationRule(
                pattern=r"def\s+main\s*\(|if\s+__name__\s*==\s*['\"]__main__['\"]",
                category="Main/Entry",
                reasoning="Contains main function or entry point pattern",
                created_at=datetime.now()
            ),
            # Initialization functions
            ClassificationRule(
                pattern=r"def\s+__init__\s*\(|def\s+initialize|def\s+setup",
                category="Initialization",
                reasoning="Constructor or initialization function pattern",
                created_at=datetime.now()
            ),
            # API endpoints
            ClassificationRule(
                pattern=r"@(app|router)\.(get|post|put|delete|patch)|async\s+def\s+handle_|def\s+api_",
                category="API",
                reasoning="REST API endpoint decorator or handler function pattern",
                created_at=datetime.now()
            ),
            # Database operations
            ClassificationRule(
                pattern=r"(SELECT|INSERT|UPDATE|DELETE)\s+.*FROM|def\s+(get|save|update|delete)_\w+_from_db",
                category="Database",
                reasoning="SQL query pattern or database operation function naming",
                created_at=datetime.now()
            ),
            # Utility functions
            ClassificationRule(
                pattern=r"def\s+(convert|transform|parse|format|validate|check)_",
                category="Utility",
                reasoning="Common utility function naming patterns",
                created_at=datetime.now()
            ),
            # Error handling
            ClassificationRule(
                pattern=r"except\s+\w+|raise\s+\w+|def\s+handle_error|class\s+\w+Error",
                category="Error Handling",
                reasoning="Exception handling or error-related patterns",
                created_at=datetime.now()
            ),
            # Configuration
            ClassificationRule(
                pattern=r"def\s+(load|read|get)_config|class\s+\w*Config",
                category="Configuration",
                reasoning="Configuration loading or config class patterns",
                created_at=datetime.now()
            ),
            # Logging
            ClassificationRule(
                pattern=r"logging\.(debug|info|warning|error|critical)|logger\.|def\s+log_",
                category="Logging",
                reasoning="Logging statement or logging function patterns",
                created_at=datetime.now()
            )
        ]
        
        for rule in default_rules:
            conn.execute(
                "INSERT INTO classification_rules (pattern, category, reasoning, created_at) VALUES (?, ?, ?, ?)",
                (rule.pattern, rule.category, rule.reasoning, rule.created_at.isoformat())
            )
        conn.commit()
        self.logger.info(f"Added {len(default_rules)} default classification rules")
    
    def save_rule(self, rule: ClassificationRule) -> int:
        """Save a new classification rule to the database."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    "INSERT INTO classification_rules (pattern, category, reasoning, created_at, success_count, failure_count) VALUES (?, ?, ?, ?, ?, ?)",
                    (rule.pattern, rule.category, rule.reasoning, rule.created_at.isoformat(), rule.success_count, rule.failure_count)
                )
                conn.commit()
                return cursor.lastrowid
        except sqlite3.Error as e:
            self.logger.error(f"Failed to save classification rule: {e}")
            raise
    
    def get_rules_for_category(self, category: str) -> List[ClassificationRule]:
        """Get all rules for a specific category."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    "SELECT pattern, category, reasoning, created_at, success_count, failure_count FROM classification_rules WHERE category = ?",
                    (category,)
                )
                rules = []
                for row in cursor:
                    rules.append(ClassificationRule(
                        pattern=row[0],
                        category=row[1],
                        reasoning=row[2],
                        created_at=datetime.fromisoformat(row[3]),
                        success_count=row[4],
                        failure_count=row[5]
                    ))
                return rules
        except sqlite3.Error as e:
            self.logger.error(f"Failed to get rules for category {category}: {e}")
            return []
    
    def get_all_rules(self) -> List[ClassificationRule]:
        """Get all classification rules."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    "SELECT pattern, category, reasoning, created_at, success_count, failure_count FROM classification_rules"
                )
                rules = []
                for row in cursor:
                    rules.append(ClassificationRule(
                        pattern=row[0],
                        category=row[1],
                        reasoning=row[2],
                        created_at=datetime.fromisoformat(row[3]),
                        success_count=row[4],
                        failure_count=row[5]
                    ))
                return rules
        except sqlite3.Error as e:
            self.logger.error(f"Failed to get all rules: {e}")
            return []
    
    def update_rule_stats(self, pattern: str, category: str, success: bool):
        """Update success/failure statistics for a rule."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                if success:
                    conn.execute(
                        "UPDATE classification_rules SET success_count = success_count + 1 WHERE pattern = ? AND category = ?",
                        (pattern, category)
                    )
                else:
                    conn.execute(
                        "UPDATE classification_rules SET failure_count = failure_count + 1 WHERE pattern = ? AND category = ?",
                        (pattern, category)
                    )
                conn.commit()
        except sqlite3.Error as e:
            self.logger.error(f"Failed to update rule stats: {e}")